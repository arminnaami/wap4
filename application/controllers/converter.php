<?php  if ( ! defined('BASEPATH')) exit('No direct script access allowed');
ignore_user_abort(true);
set_time_limit(0);
setlocale(LC_ALL, 'en_US.UTF8');
//error_reporting(E_ALL);
//ini_set('display_errors', 1);
//ini_set('log_errors', 1);
class Converter extends CI_Controller
{
    
    /**
     * Array of errors
     * @var array
     */
    var $aError;
    
    /**
     * sanitized video title without extension
     * @var string
     */
    public $title;
    
    /**
     * Unique ID for converter generated by uniqid();
     * @var string 
     */
    public $uniqid;
    
    /**
     * Extension of uploaded file
     * @var string 
     */
    public $extension;
    /**
     * Multimedia link
     * @var string
     */
    public $link;

    
    static function test() {
        
        return true;
        
    }
    
    public function __construct() 
    {
        parent::__construct();
        $this->load->model('ffmpeg_model');
        $this->load->helper('wap4');
        load_settings();
        $this->aError = array();
        $this->data["meta"] = "converter";
        
        $this->_set_uniqid_and_link();
        
        if($this->link) {
            $this->load->library('downloader');
            $this->downloader->sLink = $this->link;
            $this->downloader->sUniqueId = $this->uniqid;
        }
    }
   
   /**
    * Destructor to log errors
    */
   function __destruct() {
       
       if(!empty($this->aError)) {
           file_put_contents($this->config->item("ffmpeg_files_dir")."error_log",
           date("Y-m-d H:i:s")." :: ".implode(" ** ", $this->aError)."\n", FILE_APPEND);
       }
       
   }
   
   public function phpinfo() {
       phpinfo();
   }
    
   private function _set_uniqid_and_link() {
       
        if($this->input->get_post('key')
                && ctype_alnum($this->input->get_post('key'))
                && strlen($this->input->get_post('key')) == 13) {
            
            $this->uniqid = $this->input->get_post('key');
            
        } else if($this->uri->segment(4)
                && ctype_alnum($this->uri->segment(4))
                && strlen($this->uri->segment(4)) == 13) {
            
            $this->uniqid = $this->uri->segment(4);

        } else
            $this->uniqid = uniqid();
        
        if($this->input->get_post('link'))
            $this->link = trim($this->input->get_post('link', FALSE));
        
   }
   
   
   function is_size_within_upload_limit($sUniqueId) {
       
        $this->db->reconnect();
        $aVideoData = $this->ffmpeg_model->get_video($sUniqueId);
        if(isset($aVideoData->video_size) && $aVideoData->video_size > $this->data['max']*1024) {
            
            $sErr = "Video $sUniqueId  has bigger data size (".ceil(($aVideoData->video_size/1024)/1024)."MB) than MAX allowed (".($this->data['max']/1024)."MB)";
            
            $this->db->reconnect();
            $aParams = array('uniqid' => $this->uniqid,
                            'is_failed' => 1,
                            'fail_log' => $sErr);
            $this->ffmpeg_model->set_video($aParams);
            
            return FALSE;
            
        } else {
            
            return TRUE;
            
        }
       
   }
   
    /**
     * Shows converter interface
     */
    function index()
    {
        
	$this->data['message'] = '';
    	$this->data['users']   = '';
        $this->data['attr']    = array('id' => 'conv');
	$this->data['formats'] = $this->ffmpeg->ffmpeg_formats;
        $this->data['uniqid']  = $this->uniqid;
        $this->data['extensions'] = $this->config->item('ffmpeg_extensions');
        
	$this->datb['allowed'] = "'".implode("','", $this->config->item('ffmpeg_allowed'))."'";
        $this->datb['max']     = $this->data['max'];
        $this->datb['uniqid']  = $this->uniqid;
        
        $aData['data'] = $this->data;
        $this->load->view('v2/includes/header', $aData);
        
        if($_SERVER["SERVER_NAME"] == $this->config->item("mobile_host") || $_SERVER["SERVER_NAME"] == "testm.wap4.org")
            $this->load->view('v2/converter_no_js', $this->data);
        else
            $this->load->view('v2/converter', $this->data);
        
        $this->load->view('v2/includes/footer', $aData);
    	
    }

    
    
    
    /**
     * Starts uploading video from Youtube/Vimeo/Yahoo/Google...
     */
    function link_upload($sReturn = FALSE, $bRunInBackground = TRUE)
    {
        $this->db->reconnect();
        //check if recognized as one of video sites
        if($this->downloader->is_link_recognized($this->link)) {
            
            //link is recognized
            log_message('debug', 'link: '.$this->link.' is recognized as video sharing website :)');
            
            $this->title = $this->get_title($this->link, TRUE, TRUE);
            if($this->title === FALSE) {
                log_message('error', '$this->get_title('.$this->link.', TRUE, TRUE); returned FALSE!');
                if($sReturn === TRUE) {
                    return FALSE;
                } else {
                    echo lang('upload.fail');
                    $this->write_fail_report("fail.title $this->link", $this->uniqid);
                    exit;
                }
            }
            
            $this->downloader->sUploadPath = $this->config->item("ffmpeg_before_dir");
            $this->downloader->sFileBody = $this->title;
            
            $sFormat = $this->input->post('convert_format');
            
            if(in_array($sFormat, array('3gp-352x288-amr','mp4-640x360-aac')))
                $nYoutubeFormat = 18;
            else
                $nYoutubeFormat = 5;
            
            $bIsFileDownloadStarted = $this->downloader->download_file($bRunInBackground,$nYoutubeFormat);
            log_message('debug', 'download_file() function complete for recognized link :)');
            //log_message('debug', 'test3');
            //wait some time till python script's outputs Destination of file to get extension
            //if($bRunInBackground !== FALSE)
                sleep(4); 
            //log_message('debug', 'test4');
            //save file extension to DB
            $sExtension = $this->downloader->get_extension();
            log_message('debug', 'upload extension from downloader->get_extension(): '.$sExtension);
            
            //13128172
            $sFileSize = $this->downloader->get_info('filesize');
            //echo $sFileSize;
            //check if file size is OK compared to max allowed filesize
            //echo "$\this->data['max']: {$this->data['max']} \$sFileSize: $sFileSize";
            $bIsFileSizeAllowed = $this->_is_filesize_allowed($this->data['max'], $sFileSize);
            if($bIsFileSizeAllowed === FALSE) {
                if($sReturn === TRUE) {
                    return FALSE;
                } else {
                    $this->output->set_status_header('400');
                    echo lang('upload.fail')." 1 Video is bigger (".ceil((($sFileSize/1024)/1024))."MB) than max allowed size of ".($this->data['max']/1024)."MB";
                    exit;
                }
            }
            
            //save file size in bytes to DB
            $this->db->reconnect();
            $aParams = array('uniqid' => $this->uniqid,
                            'video_size' => $sFileSize,
                            'requested_link' => $this->link,
                            'source_type' => 'known');
            $this->ffmpeg_model->set_video($aParams);
            
            if($sExtension) {
                //$this->_set_extension($sExtension, 'uploaded_video_extension');
            } else {
                $sErrMsg = 'upload extension is empty for '.$this->uniqid.'!';
                log_message('error', $sErrMsg);
            }
            
        } else {
            //link is not recognized, assuming it is direct link
            log_message('debug', 'link: '.$this->link.' is not recognized as video sharing website, trying as direct');
            //here we should already know uploaded and converter file title and extensions
            
            $sUploadedExtension = $this->get_direct_extension($this->link);
            $this->load->library('ffmpeg');
            $this->ffmpeg->setFormat($this->input->post('format'));
            $sConvertedExtension = $this->ffmpeg->getExtension();
            
            $sUploadedBody = $sConvertedBody = $this->title = $this->get_title($this->link, FALSE, TRUE);
            
            //save file size in bytes to DB
            $sFileSize = $this->get_web_content_length($this->link);
            
            //check if file size is OK compared to max allowed filesize
            $bIsFileSizeAllowed = $this->_is_filesize_allowed($this->data['max'], $sFileSize);
            if($bIsFileSizeAllowed === FALSE) {
                if($sReturn === TRUE) {
                    return FALSE;
                } else {
                    $this->output->set_status_header('400');
                    $sErr = lang('upload.fail')." 2 Video is bigger (".
                            ceil((($sFileSize/1024)/1024))."MB or $sFileSize) than max allowed size of ".
                            ($this->data['max']/1024)."MB or video size could not be determined";
                    echo $sErr;
                    
                    $this->db->reconnect();
                    $aParams = array('uniqid' => $this->uniqid,
                                    'is_failed' => 1,
                                    'fail_log' => $sErr);
                    $this->ffmpeg_model->set_video($aParams);
                    
                    exit;
                }
            }
            
            $this->db->reconnect();
            $aParams = array('uniqid' => $this->uniqid,
                            'video_size' => $sFileSize,
                            'uploaded_video_body' => $sUploadedBody,
                            'converted_video_body' => $sConvertedBody,
                            'uploaded_video_extension' => $sUploadedExtension,
                            'converted_video_extension' => $sConvertedExtension,
                            'requested_link' => $this->link,
                            'source_type' => 'direct');
            $this->ffmpeg_model->set_video($aParams);
            
            //assume video is from unrecognized direct download website
            log_message('debug', '$this->download_link started for: '.$this->link);
            $bIsFileDownloadStarted = $this->download_link($this->link, $this->title);
            log_message('debug', '$this->download_link function complete for not recognized link :)');
        }
        
        
        if($bIsFileDownloadStarted) {
            if($sReturn === TRUE) {
                return TRUE;
            } else {
                echo 'link upload started';
            }
            
        } else {
            
            $this->aError[] = "Video from $this->link could not be extracted";
            log_message("error", "Video from $this->link could not be extracted");
            if($sReturn === TRUE) {
                return FALSE;
            } else {
                $this->output->set_status_header('400');
                $sErr =  lang('upload.fail')." Link upload failed to start";
                echo $sErr;
                $this->db->reconnect();
                $aParams = array('uniqid' => $this->uniqid,
                                'is_failed' => 1,
                                'fail_log' => $sErr);
                $this->ffmpeg_model->set_video($aParams);
                
            }

        }

    }
    
    /**
     * Check if video file size is allowed
     * @assert (100, 99) === true
     * @assert (99, 100) === false
     * @param type $nAllowedSize
     * @param type $nVideoSize
     * @return bool 
     */
    private function _is_filesize_allowed($nAllowedSize, $nVideoSize) {
        
        $nAllowedSize = (int)$this->data['max']*1024;
        $nVideoSize = (int)$nVideoSize;
        //echo "\n\$nAllowedSize: $nAllowedSize \$nVideoSize: $nVideoSize";
        if($nAllowedSize < $nVideoSize) {
            //echo "test1";
            //file size too big
            $sErrMsg = "Video 3 from $this->link is bigger (".ceil((($nVideoSize/1024)/1024))."MB) than max allowed size of ".($this->data['max']/1024)."MB ";
            $this->aError[] = $sErrMsg;
            log_message("error", $sErrMsg);
            
            $aParams = array('uniqid' => $this->uniqid,
                'is_failed' => 1,
                'fail_log' => $sErrMsg);
            $this->db->reconnect();
            $this->ffmpeg_model->set_video($aParams);
            
            return FALSE;

        } elseif(intval($nVideoSize) == 0){
            //echo "test2";
            $sErrMsg = "Video from $this->link has empty size";
            $this->aError[] = $sErrMsg;
            log_message("error", $sErrMsg);
            
            $aParams = array('uniqid' => $this->uniqid,
                'is_failed' => 1,
                'fail_log' => $sErrMsg);
            $this->db->reconnect();
            $this->ffmpeg_model->set_video($aParams);
            
            return FALSE;
            
        } else {
            //echo "test3";
            //file size ok
            log_message('debug', 'file in link is OK size. link size: '.$nVideoSize.' and max allowed is: '.intval($this->data['max']*1024).'!');

            return TRUE;
        }
    }
    
    /**
     * Reads headers of web page to get content size
     * @param string $link
     * @return integer on success, boolean false on failure 
     */
    function get_web_content_length($link) {
        
        $ch = curl_init($link);
        curl_setopt($ch, CURLOPT_NOBODY, true);
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
        curl_setopt($ch, CURLOPT_HEADER, true);
        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);
        $data = curl_exec($ch);
        curl_close($ch);

        if (preg_match('/Content-Length: (\d+)/', $data, $matches)) {
          return (int)$matches[1];
        } else {
            $sWebServer = str_replace('http://', '', $link);
            $sWebServer = current(explode("/", $sWebServer));
            $sErrMsg = "Unknown content length for url: $link because web server $sWebServer doesn't show content-length before downloading";
            $this->aError[] = $sErrMsg;
            log_message('error', $sErrMsg);
            
            $aParams = array('uniqid' => $this->uniqid,
                'is_failed' => 1,
                'fail_log' => $sErrMsg);
            $this->db->reconnect();
            $this->ffmpeg_model->set_video($aParams);
            
            return FALSE;
        }

    }
    
    /**
     * Checks and sets file extension
     * @assert('unknown_extension') === false
     * @assert('mp4') === true
     * @param type $sExt
     * @param string $sExtType
     * @param type $sUniqueId
     * @return type 
     * @access private
     */
    private function _set_extension($sExt, $sExtType = 'uploaded_video_extension', $sUniqueId = FALSE)
    {
        $sMsg = 'extension: '.$sExt.', ext type: '.$sExtType.',  uniqid: '.$sUniqueId;
        log_message('debug', $sMsg);

        if(!$sExt) {
            
            $sErrMsg = 'Empty extension for video file ';
            $aParams = array('uniqid' => $this->uniqid,
                'is_failed' => 1,
                'fail_log' => $sErrMsg);
            $this->db->reconnect();
            $this->ffmpeg_model->set_video($aParams);
            
            return FALSE;
            
        }
            
        
        if(!in_array($sExt, $this->config->item("ffmpeg_allowed"))) {
            
            $sErrMsg = 'Extension "'.$sExt.'" not supported ';
            $aParams = array('uniqid' => $this->uniqid,
                'is_failed' => 1,
                'fail_log' => $sErrMsg);
            $this->db->reconnect();
            $this->ffmpeg_model->set_video($aParams);
            
            return FALSE;
        }
        
        if($sExtType != 'uploaded_video_extension')
            $sExtType = 'converted_video_extension';
        
        if($sUniqueId === FALSE)
            $sUniqueId = $this->uniqid;
        
        $this->db->reconnect();
        $aParams = array('uniqid' => $this->uniqid,
                        $sExtType => $sExt);
        $this->ffmpeg_model->set_video($aParams);
        //$sExtFile = $this->config->item("ffmpeg_key_dir")."".$this->uniqid.".extension";
        //file_put_contents($sExtFile, $sExt);
        return TRUE;
        
    }
    
    function ajax_is_link_recognized() {
        
        $bIsLinkRecognized = $this->downloader->is_link_recognized();
        if($bIsLinkRecognized === FALSE)
            echo "no";
        else
            echo "yes";
        exit;
        
    }
    
    
    /**
     * Get Youtube/Vimeo/Google video SEO title
     * @param string $link
     * @param boolean $return
     * @return boolean FALSE if failure, string if title found 
     */
    function get_title($link = FALSE, $isFromVideoSharingSite = FALSE, $return = FALSE) {
        
        //$sTitleFile = $this->config->item("ffmpeg_key_dir")."".$this->uniqid.".title";
        
        $this->db->reconnect();
        $aVideoData = $this->ffmpeg_model->get_video($this->uniqid);
        
        if(!empty($aVideoData->uploaded_video_body))
             $this->title = $aVideoData->uploaded_video_body;
        else {
        
            //$isFromVideoSharingSite = $this->downloader->is_link_recognized();
            
            if($isFromVideoSharingSite === TRUE ||
                    ($this->input->get_post('ajax') == 'yes') && $this->input->get_post('is_link_recognized') == 'yes') {
                
                $title = $this->downloader->get_title();
                $this->title = translit(sanitize_name($title));

                if(!$this->title)
                    return FALSE;
                $this->db->reconnect();
                $aParams = array('uniqid' => $this->uniqid,
                                'video_title' => $title,
                                'uploaded_video_body' => $this->title,
                                'converted_video_body' => $this->title);
                $this->ffmpeg_model->set_video($aParams);
            
            } else {
                
                $this->title = $this->get_direct_title($this->link, $this->uniqid);
                if($this->title) {
                    $this->db->reconnect();
                    $aParams = array('uniqid' => $this->uniqid,
                                    'video_title' => $this->title,
                                    'uploaded_video_body' => $this->title,
                                    'converted_video_body' => $this->title);
                    $this->ffmpeg_model->set_video($aParams);
                
                }
            }
            //file_put_contents($sTitleFile, $this->title);
        
        }
        
        if(!$return)
            echo $this->title;
        else
            return $this->title;
    }
    
    public function get_extension($sUniqueId = FALSE, $sExtType = 'uploaded_video_extension', $return = FALSE) {
        
        if($sUniqueId === FALSE)
            $sUniqueId = $this->uniqid;
        
        if($sExtType != 'uploaded_video_extension')
            $sExtType = 'converted_video_extension';
        $this->db->reconnect();
        $aVideoData = $this->ffmpeg_model->get_video($sUniqueId);
        if($return === FALSE)
            echo $aVideoData->$sExtType;
        else
            return $aVideoData->$sExtType;
        
    }

    
    /**
     * Get Title from link and save to file
     * @param string $link
     * @return string $this->title
     */
    function get_direct_extension($link) {
        if(!$link) {
            $this->aError[] = "Direct link not found";
        }
        
        /**
         * Get everything after last dot
         */
        $sUploadedExtension = end(explode(".", $link));
        
        $aAllowedExtensions = $this->config->item("ffmpeg_allowed");
                    
        if(in_array(strtolower($sUploadedExtension), $aAllowedExtensions)) {
            return $sUploadedExtension;
        } else {
            log_message('error', 'uploaded extension: '.$sUploadedExtension.' not allowed for link: '.$link);
            return FALSE;
        }
    }
    
    
    /**
     * Get Title from link and save to file- NOT NEEDED NOW
     * @param string $link
     * @return string $this->title
     */
    function get_direct_title($link, $uniqid) {
        
        return $uniqid;
        
        
        if(!$link) {
            $this->aError[] = "Direct link not found";
        }
        
        /**
         * Get everything after last slash
         */
        $link = end(explode("/", $link));
        
        /**
         * If after slash there is dot somewhere, we get everything
         * before first dot symbol
         */
        $pos = stripos($link, ".");
        if($pos !== false) {
            $link = current(explode(".", $link));
        }
        
        $this->title = translit(sanitize_name($link));
        /**
         * Put Direct link title in $uniqid.title
         */
        //file_put_contents($this->config->item("ffmpeg_key_dir")."".$uniqid.".title", $this->title);
        
        return $this->title;
    }
    
    /**
     * How much percents uploaded already for Youtube/Vimeo/other videos
     * @todo use downloader to check percents
     * @uses ajax
     */
    function upload_status($key, $title = "", $return = FALSE)
    {
        
        if(!$return) {
            
            header("Cache-Control: no-cache, must-revalidate"); // HTTP/1.1
            header("Expires: Sat, 26 Jul 1997 05:00:00 GMT"); // Date in the past
            
        }

        sleep(2);
        $this->db->reconnect();
        $aVideoData = $this->ffmpeg_model->get_video($key);
        //print_r($aVideoData);
        
        if($aVideoData) {
            $sUploadTotalSize = $aVideoData->video_size;
        } else {
            
            log_message('error', 'video data for upload status not found for key '.$key);
            if(!$return) {
                echo 0;
                exit;
                
        } else
                return 0;
            
        }
        $sDownloadingFile = $this->config->item("ffmpeg_before_dir").$key;
        
        $this->load->library('downloader');
        $this->downloader->sUniqueId = $key;
        $status = $this->downloader->get_info('percents');
        
        if(!$status) {
            
            if(is_file($sDownloadingFile.".part")) {
                log_message('debug', 'using '.$sDownloadingFile.'.part to check upload progress');
                $size_local  = filesize($sDownloadingFile.".part");
            } else if(is_file($sDownloadingFile)) {
                log_message('debug', 'using '.$sDownloadingFile.' to check upload progress');
                $size_local  = filesize($sDownloadingFile);
            } else {
                log_message('error', 'there are no .part and without .part file '.$sDownloadingFile);
                $size_local = 0;
            }
            
            if($sUploadTotalSize > 0)
                $status = round(($size_local/$sUploadTotalSize)*100);
            else
                $status = 0;
            
        }
        
        if($status > 100) {
            $status = 100;
        }
        
        log_message('debug', 'uploaded so far: '.$status.' percents');
        
        if(!$return)
            echo $status;
        else
            return $status;

    }
    
    /**
     * Allows changing max upload sizes for administrator level users
     */
    function change_settings() {
        $this->load->library('form_validation');
        /**
         * validate form input
         */
    	$this->form_validation->set_rules('unregistered', 'unregistered', 'numeric|min_length[1]|max_length[3]');
		$this->form_validation->set_rules('registered', 'registered', 'numeric|min_length[1]|max_length[3]');
        
        $this->data['unregistered']   = array('name'    => 'unregistered',
                                      'id'      => 'unregistered',
                                      'type'    => 'text',
                                      'value'   => $this->form_validation->set_value('unregistered'),
                                     );
        $this->data['registered']   = array('name'    => 'registered',
                                      'id'      => 'registered',
                                      'type'    => 'text',
                                      'value'   => $this->form_validation->set_value('registered'),
                                     );

        if ($this->form_validation->run() == true) {
        	
        	if ($this->site_model->update_sizes($this->input->post('unregistered'), $this->input->post('registered'))) {
                        /**
                         * if the change is successful
                         * redirect back to the home page
                         */
	        	$this->session->set_flashdata('message', $this->ion_auth->messages());
	        	redirect($this->config->item('base_url'), 'refresh');
	        } else {
                    /**
                     * if the setting change was un-successful
                     */
                    $this->session->set_flashdata('message', "bad values");
                    $this->data['message'] = "bad values";
                    $this->load->view('change_settings', $this->data);

	        }
        } else {
            /**
             * set the flash data error message if there is one
             */
            $this->data['message'] = (validation_errors()) ? validation_errors() : $this->session->flashdata('message');
            
            $this->load->view('change_settings', $this->data);
            }
    }
    
    /**
     * Outputs progress of conversion for mobile devices
     * @param string $key - uniqid key
     */
    function mobile_status($key) {
        
        $data["key"]   = $this->uniqid = $key;
        $this->db->reconnect();
        $aVideoData = $this->ffmpeg_model->get_video($key);
        //print_r($aVideoData);
        $sUploadBody = '';
        $sUploadExtension = '';
        $sUploadTotalSize = '';
        if($aVideoData) {
            $sUploadBody = $aVideoData->uploaded_video_body;
            $sUploadExtension = $aVideoData->uploaded_video_extension;
            $sUploadTotalSize = $aVideoData->video_size;
        }
        
        if(empty($sUploadExtension) || empty($sUploadTotalSize)) {
            sleep(2);
            $this->load->library('downloader');
            $this->downloader->sUniqueId = $key;
            //save file size in bytes and upload extension to DB
            $sExtension = $this->downloader->get_extension();
            $sFileSize = $this->downloader->get_info('filesize');
            log_message('debug', 'upload extension from downloader->get_extension(): '.$sExtension);
            $this->db->reconnect();
            
            if(!empty($sFileSize) && !empty($sExtension)) {
            
                $aParams = array('uniqid' => $this->uniqid,
                                'video_size' => $sFileSize,
                                'uploaded_video_extension' => $sExtension);
                $this->ffmpeg_model->set_video($aParams);

                if($sExtension) {
                    //$this->_set_extension($sExtension, 'uploaded_video_extension');
                } else
                    log_message('error', 'upload extension is empty for '.$this->uniqid.'!');
            
            }
        }
        
        $data["Upload_percents_complete"]  = $this->upload_status($key, $sUploadBody, TRUE);
        $data["Convert_percents_complete"] = $this->convert_status($key, TRUE);
        
        /**
         * if file is uploaded and converter hasn't started, start conversion
         * @todo check if ffmpeg process with this file name exists
         * @todo insert converted video extension and converter options as soon as possible in DB
         */
        if($data["Upload_percents_complete"] == 100 &&
                (!isset($aVideoData->is_uploaded) || $aVideoData->is_uploaded == 0)) {
            
            $bIsUploadLimitOK = $this->is_size_within_upload_limit($key);
            if($bIsUploadLimitOK === TRUE) {
                
                //check if already converts
                $sCmd = "ps -ef | grep -c 'files/uploaded/$key'";
                exec($sCmd, $aOutput, $nReturn);
                if($aOutput[0] > 1) { //not only grep process but also converter
                    //file already converts so skip
                } else {
                    //file doesn't convert- start converting
                    $this->link = $aVideoData->requested_link;

                    $this->load->library('downloader');
                    $this->downloader->sLink = $this->link;
                    $this->downloader->sUniqueId = $this->uniqid;
                    
                    if($this->downloader->is_link_recognized() === TRUE)
                        $sType = 'known';
                    else
                        $sType = 'direct';

                    $this->title = $this->get_title($this->link, TRUE, TRUE);
                    $sExtension = $this->downloader->get_extension();

                    $aExtensions = $this->config->item('ffmpeg_extensions');
                    $aExtKeys = array_keys($aExtensions);
                    if(in_array($aVideoData->converter_option, $aExtKeys)) {
                        log_message('debug', 'mobile_status: format: '.$aVideoData->converter_option.' is in array of '. implode(',', $aExtKeys));
                        $this->_set_extension($aExtensions[$aVideoData->converter_option], 'converted_video_extension');
                    } else {
                        log_message('error', 'mobile_status: format: '.$aVideoData->converter_option.' is NOT in array of'. implode(',', $aExtKeys));
                    }

                    $this->db->reconnect();
                    $aParams = array('uniqid' => $this->uniqid,
                                    'uploaded_video_body' => $this->title,
                                    'converted_video_body' => $this->title,
                                    'uploaded_video_extension' => $sExtension,
                                    'requested_link' => $this->link,
                                    'source_type' => $sType);
                    $this->ffmpeg_model->set_video($aParams);
                    
                    $sIsLoggedIn = $this->ion_auth->logged_in() ? 'yes' : 'no';
                    $sLink = "http://m.wap4.org/en/converter/start_converter/$this->uniqid/$this->title/$sExtension/$aVideoData->converter_option/$aVideoData->converter_quality";
                    $command = "wget --post-data 'is_logged_in=$sIsLoggedIn' $sLink -b -O /dev/null -o ".$this->config->item("ffmpeg_key_dir").$key.".wget_alt >/dev/null 2>&1";
                    log_message('debug', $command);
                    exec($command, $arrr);
                    $data['warning'] = " Warning: started alternative conversion which might not work. Please wait and reload after a while";

                }

            }
            
            
        }
        
        $data["fail_array"] = $this->read_fail_report_into_array($key);
        
        if($data["Convert_percents_complete"] >= 98) {
            
            $extension = "mp3";
            
            $oVideo = $this->ffmpeg_model->get_video($key);
            
            $file = file($this->config->item("ffmpeg_key_dir")."ffmpeg-$oVideo->ffmpeg_log_date.log");
            
            foreach($file as $f) {
                if(substr($f, 0, 6) == "Output") {
                    $extension = substr(end(explode(".", $f)), 0, -3);
                    break;
                }
            }
            $data["download_url"] = $_SERVER["SERVER_NAME"].
            "/files/converted/$key.$extension";
            //$this->load->library('ffmpeg');
            //$this->ffmpeg->cleanAfterConverter($this->uniqid);
        }
        
        if(!empty($aVideoData->is_failed) && !empty($aVideoData->fail_log))
        $data["fail_array"][] = $aVideoData->fail_log;
        
        $this->load->view("mobile_status", $data);
    }
    
    
    public function start_converter($sUniqId, $sTitle, $sExtension, $sFormat, $sQuality)
    {
        
        $bIsUploadLimitOK = $this->is_size_within_upload_limit($sUniqId);
        if($bIsUploadLimitOK === FALSE)
            exit;
        
                
        $this->load->library('ffmpeg');
        $this->ffmpeg->setInputFile($sTitle.".".$sExtension);
        //convert options
        $this->ffmpeg->setKey($sUniqId);
        $this->ffmpeg->setFormat($sFormat);
        $this->ffmpeg->setQuality($sQuality);
        //set cut options, if needed
        $this->ffmpeg->startConvert("no_js");
    }
    
    /**
     * Convert function which handles logic of converting videos
     * @global string $title - sanitized title of Youtube video
     */
    function convert()
    {
        $sCmd = "ps -ef | grep -c 'ffmpeg'";
        exec($sCmd, $aOutput, $nReturn);
        
        if($aOutput[0] > $this->config->item('ffmpeg_max_processes')) {
            $sErrMsg = "MAX simultaneous conversions reached for server. Too many ffmpeg processes (with grep process together it is: ".$aOutput[0].") now. Please try again later";
            log_message('error', $sErrMsg);
            $this->output->set_status_header('400');
            
            $aParams = array('uniqid' => $this->uniqid,
                'is_failed' => 1,
                'fail_log' => $sErrMsg);
            $this->ffmpeg_model->set_video($aParams);
            
            echo $sErrMsg;
            exit;
            
        } else {
            log_message('debug', 'process count (with grep process) is OK: '.$aOutput[0]);
        }
        /**
         * Youtube/Vimeo/Yahoo/Google converter for mobile devices
         */
        if(isMobile() &&
            !isset($_REQUEST["from"]) &&
            $_SERVER["REMOTE_ADDR"] != $_SERVER["SERVER_ADDR"] &&
            !empty($_REQUEST["link"])
           ) {
            
            $aParams = array('uniqid' => $this->uniqid,
                'requested_link' => $this->input->post('link'),
                'converter_option' => $this->input->post('format'),
                'convert_quality' => $this->input->post('quality'));
            $this->ffmpeg_model->set_video($aParams);
            
            if(!is_file($this->config->item("ffmpeg_key_dir").$_REQUEST["key"].".wget"))
            $this->ping_link("http://".$_SERVER["SERVER_NAME"]."/".$this->lang->lang()."/converter/convert/no_js", $_REQUEST["key"]);
            
            redirect('converter/mobile_status/'.$_REQUEST["key"], 'location');
            exit;
            
        }
        // no javascript or mobile version
        if($this->uri->segment(4) == "no_js")
        {
            //file upload + conversion for mobile version
            if(isset($_FILES['qqfile']['tmp_name']) && !empty($_FILES['qqfile']['tmp_name'])) {
                if(intval($this->data['max']*1024) > intval($_FILES['qqfile']['size']))
                {
                    
                    $file_body = current(explode(".",$_FILES['qqfile']['name']));
                    $file_body = translit(sanitize_name($file_body));
                    $file_end  = end(explode(".",$_FILES['qqfile']['name']));
                    
                    $ext = $this->config->item("ffmpeg_allowed");
                    
                    if (!in_array(strtolower($file_end), $ext)) {
                        log_message('error', 'security warning: upload file extension: '.$file_end.' not allowed');
                        $this->write_fail_report("fail.extension $file_end allowed: ".implode(', ', $ext), $_POST["key"]);
                        die('security warning: security warning: upload file extension: '.$file_end.' not allowed');
                    }
                    
                    if (!move_uploaded_file($_FILES['qqfile']['tmp_name'],
                        $this->config->item('ffmpeg_before_dir').$this->uniqid)) {
                        $this->aError[] = "move_uploaded_file error, when trying
                            to upload file in no_js";
                        $this->write_fail_report("fail.upload", $_POST["key"]);
                        die("fatal error, when trying to upload file");
                    }

                    $this->ffmpeg->setInputFile($file_body.".".$file_end, "no_js");
                    
                } else {
                    
                    /**
                     * if file is too big- error
                     */
                    $sErr = "too big file {$_FILES['qqfile']['size']},
                    max filesize {$this->data['max']} MB";
                    
                    $this->aError[] = $sErr;
                    
                    $this->db->reconnect();
                    $aParams = array('uniqid' => $this->uniqid,
                                    'is_failed' => 1,
                                    'fail_log' => $sErr);
                    $this->ffmpeg_model->set_video($aParams);
                    
                    $this->write_fail_report("fail.size ".$_FILES['qqfile']['size'], $_POST["key"]);
                    die($sErr);
                    
                }
            }
            //link upload + conversion for mobile version
            if(!empty($_POST["link"])) {
                
                //upload
                log_message('debug', 'link upload started!');
                $bIsUploaded = $this->link_upload(TRUE, FALSE);
                log_message('debug', 'link upload ended!');
                if($bIsUploaded === FALSE) {
                    log_message('error', 'link upload gone bad!');
                } else {
                    log_message('debug', 'link upload OK!');
                }
                
                $sExtension = $this->get_extension($this->uniqid, 'uploaded_video_extension', TRUE);

                $aExtensions = $this->config->item('ffmpeg_extensions');
                $aExtKeys = array_keys($aExtensions);
                if(in_array($this->input->post('format'), $aExtKeys)) {
                    log_message('debug', 'format: '.$this->input->post('format').' is in array of '. implode(',', $aExtKeys));
                    $this->_set_extension($aExtensions[$this->input->post('format')], 'converted_video_extension');
                } else {
                    log_message('error', 'format: '.$this->input->post('format').' is NOT in array of'. implode(',', $aExtKeys));
                }

                $this->ffmpeg->setInputFile($this->title.".".$sExtension);

            }

        $this->db->reconnect();
        $aVideoData = $this->ffmpeg_model->get_video($this->uniqid);
        if(isset($aVideoData->video_size) && $aVideoData->video_size > $this->data['max']*1024) {
            
            $sErr = "Video $this->uniqid  has bigger data size ($aVideoData->video_size) than MAX allowed (".($this->data['max']*1024).")";
            
            $this->db->reconnect();
            $aParams = array('uniqid' => $this->uniqid,
                            'is_failed' => 1,
                            'fail_log' => $sErr);
            $this->ffmpeg_model->set_video($aParams);
            exit;
            
        }
        
        $bIsUploadLimitOK = $this->is_size_within_upload_limit($this->uniqid);
        if($bIsUploadLimitOK === FALSE)
            exit;
            
            //convert options
            $this->ffmpeg->setKey($this->input->post('key'));
            $this->ffmpeg->setFormat($this->input->post('format'));
            $this->ffmpeg->setQuality($this->input->post('quality'));
            //set cut options, if needed
            if($this->input->post('cut') == 'yes')
            $this->ffmpeg->cut( $this->input->post('s_hh'),
                                $this->input->post('s_mm'),
                                $this->input->post('s_ss'),
                                $this->input->post('e_hh'),
                                $this->input->post('e_mm'),
                                $this->input->post('e_ss'));
            
            $veids="no_js";
            
        } else {
            //js version with ajax
            
            
            $bIsUploadLimitOK = $this->is_size_within_upload_limit($this->uri->segment(4));
            if($bIsUploadLimitOK === FALSE)
                exit;

            $this->ffmpeg->setKey($this->uri->segment(4));
            $this->ffmpeg->setFormat($this->uri->segment(5));
            $this->ffmpeg->setQuality($this->uri->segment(15));
            $this->ffmpeg->setInputFile($this->uri->segment(6));

            if($this->uri->segment(7) == 'yes')
                $this->ffmpeg->cut( $this->uri->segment(8),
                                $this->uri->segment(9),
                                $this->uri->segment(10),
                                $this->uri->segment(11),
                                $this->uri->segment(12),
                                $this->uri->segment(13));

            $veids="js";
        
        }
        
        $this->ffmpeg->startConvert($veids);
        
        echo current(explode(".", strtolower($this->uri->segment(6))));
    }
    
    /**
     * Returns percents complete of conversion
     * @param string $unikaalais - uniqid string
     * @param boolean $return - true- returns result, false- outputs result
     * @return type 
     */
    function convert_status($unikaalais, $return = false) {
        
        $this->load->library('ffmpeg');
        $this->ffmpeg->setKey($unikaalais);
        
        $converter_completed_percents = $this->ffmpeg->getPercentsComplete();
        
        if($converter_completed_percents > 98)
            $converter_completed_percents = 100;
        
        log_message('debug', 'converted so far: '.$converter_completed_percents.' percents');
        
        if(!$return) {
            
            header("Cache-Control: no-cache, must-revalidate"); // HTTP/1.1
            header("Expires: Sat, 26 Jul 1997 05:00:00 GMT");
            echo $converter_completed_percents;
            
        } else
            return $converter_completed_percents;
    }

    /**
     * removes everything after last dot symbol if dot is in string
     * and outputs result
     */
    function change_body() {
	//$gabals = substr($this->uri->segment(4), 0, -4);
        
        $pos2 = stripos($this->uri->segment(4), ".");
        if ($pos2 !== false) {
            echo current(explode(".", strtolower($this->uri->segment(4))));
        } else {
            echo strtolower($this->uri->segment(4));
        }

    }
    
    /**
     * Downloads and saves external file
     * @param string $link address of file
     * @param string $location location where to save
     * @return boolean true if success, false if failure
     */
    function download_link($link, $location, $type = "youtube") {

        $ext      = $this->config->item("ffmpeg_allowed");
        $file_end = end(explode(".", $link));
        $this->extension = $file_end;

        $loc  = $this->config->item("ffmpeg_before_dir").$location;
        $file = fopen($loc, 'w');
        if($file === FALSE) {
            $sErrMsg = "Can not open file: $location for writing";
            $this->aError[] = $sErrMsg;
            log_message("error", $sErrMsg);
            return FALSE;
        }
        log_message("debug", "started downloading $link to $loc");
        $ch = curl_init();
        curl_setopt($ch, CURLOPT_FILE, $file);
        curl_setopt($ch, CURLOPT_HEADER, 0);
        curl_setopt($ch, CURLOPT_URL, $link);
        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);
        
        curl_setopt($ch, CURLOPT_NOPROGRESS, FALSE);
        curl_setopt($ch, CURLOPT_PROGRESSFUNCTION, 'write_direct_download_percents');
        
        @curl_setopt($ch, CURLOPT_COOKIEFILE, 'COOKIE');
        @curl_setopt($ch, CURLOPT_COOKIEJAR, 'COOKIE');
        if(!curl_exec($ch)) {
            $sErrMsg = "CURL: Failed to download file: $link";
            $this->aError[] = $sErrMsg;
             log_message("error", $sErrMsg);
            return FALSE;
        }
        curl_close($ch);
        fclose($file);

        return TRUE;
    }
    
    /*function write_direct_download_percents($download_size, $downloaded, $upload_size, $uploaded) {
        
         $sPercFile = $this->config->item("ffmpeg_key_dir")."".$this->uniqid.".percents";
         
         $nPercent = round($downloaded/$download_size);
         
         file_put_contents($sPercFile,$nPercent);
         
    }*/
    
    /**
     * To run web pages in background with long loading time
     * @param string $link
     * @param string $key
     */
    function ping_link($link, $key) {
            
        $_GETPOST = array_merge($_GET, $_POST); 
        $encoded  = http_build_query($_GETPOST);
        $sIsLoggedIn = $this->ion_auth->logged_in() ? 'yes' : 'no';
        $command = "wget --post-data '$encoded&from=wget&uniq_id=$key&is_logged_in=$sIsLoggedIn' $link -b -O /dev/null -o ".
        $this->config->item("ffmpeg_key_dir").$key.".wget >/dev/null 2>&1";
        log_message('debug', $command);
        $this->aError[] = $command;
        exec($command, $arrr);

    }
    
    /**
     * Parses url and makes standard url which can  be sent later to extract
     * location of video file
     * @assert ('direct', 'wap4.org') == 'http://wap4.org'
     * @assert ('youtube', 'https://www.youtube.com/watch?v=-xN8Gd9TY5o&feature=g-all-u') == 'http://www.youtube.com/watch?v=-xN8Gd9TY5o'
     * @param string $type - vimeo, youtube etc.
     * @param string $link - URL
     * @return string on success, boolean false on failure 
     */
    function normalize_link($type, $link) {
        
        switch($type) {
            
        case "vimeo":

        if(is_numeric($link)) {
            return $link;
        } else {
            
            if(substr($link, 0, 7) != "http://")
            $link = "http://".$link;
            
            $pos = stripos($link, "/");
            if($pos !== false) {
                
                $aParts = explode("/", $link);
                $id = end($aParts);
                
                if(!is_numeric($id)) {
                    $this->aError[] = "Failed to parse Vimeo link";
                    return false;
                } else {
                    return $id;
                }
            }
        }
        break;
        
        case "direct":
            
            if(substr($link, 0, 7) != "http://")
                    $link = "http://".$link;
            
        break;
    
        default: //youtube

            if(substr($link, 0, 7) != "http://")
                    $link = "http://".$link;

            $query = parse_url($link,PHP_URL_QUERY);

            parse_str($query);

            if(!isset($v) || empty($v)) {
                $this->aError[] = "Can not parse \$v: $v from \$link: $link in upload_youtube() function";
                return false;
            }

            $link = "http://www.youtube.com/watch?v=".$v;
        
        break;
        
        }
        
        return $link;
        
    }
 
    
    /**
     * Create or append .fail file
     * file structure:
     *  language_constant(required) [space] some_data(not required)
     * @param string $text
     * @param string $uniqid 
     */
    function write_fail_report($text, $uniqid) {
        
        file_put_contents(
                $this->config->item("ffmpeg_key_dir")."".$uniqid.".fail",
                $text."\n", FILE_APPEND);
        
    }
    
    /**
     * Get array of fails
     * @param string $uniqid
     * @return array 
     */
    function read_fail_report_into_array($uniqid) {
        
        $aFailArray = array();
        $sFile = $this->config->item("ffmpeg_key_dir")."".$uniqid.".fail";
        if(is_file($sFile)) {
            $file = file($sFile);
            if(count($file) > 0) {
                foreach($file as $f) {

                    $pos = stripos($f, " ");
                    if($pos !== false) {

                        $parts = explode(" ", $f);
                        $aFailArray[] = lang($parts[0]).": ".$parts[1];

                    } else {

                        $aFailArray[] = lang($f);

                    }

                }
            }
        }
        return $aFailArray;
    }

}
